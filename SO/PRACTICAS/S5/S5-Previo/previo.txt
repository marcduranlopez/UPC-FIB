Utilizando el "man nm" podemos saber los tipos de simbolos que nos muestra nm y sus etiquetas:
    
    "A" The symbol's value is absolute, and will not be changed by further linking.
    
    "B"
    "b" The symbol is in the BSS data section.  This section typically contains zero-initialized or uninitialized data, although the exact behavior is system dependent.

    "C" The symbol is common.  Common symbols are uninitialized data.  When linking, multiple common symbols may appear with the same name.  If the symbol is defined anywhere, the common symbols are treated as undefined references.

    "D"
    "d" The symbol is in the initialized data section.

    "G"
    "g" The symbol is in an initialized data section for small objects.  Some object file formats permit more efficient access to small data objects, such as a global int variable as opposed to a large global array.

    "i" For PE format files this indicates that the symbol is in a section specific to the implementation of DLLs.  For ELF format files this indicates that the symbol is an indirect function.  This is a GNU extension to the standard set of ELF symbol types.  It indicates a symbol which if referenced by a relocation does not evaluate to its address, but instead must be invoked at runtime.  The runtime execution will then return the value to be used in the relocation.

    "I" The symbol is an indirect reference to another symbol.
    
    "N" The symbol is a debugging symbol.
    
    "n" The symbol is in the read-only data section.
    
    "p" The symbol is in a stack unwind section.
    
    "R"
    "r" The symbol is in a read only data section.
    
    "S"
    "s" The symbol is in an uninitialized or zero-initialized data section for small objects.
    
    "T"
    "t" The symbol is in the text (code) section.
    
    "U" The symbol is undefined.
    
    "u" The symbol is a unique global symbol.  This is a GNU extension to the standard set of ELF symbol bindings.  For such a symbol the dynamic linker will make sure that in the entire process there is just one symbol with this name and type in use.
    
    "V"
    "v" The symbol is a weak object.  When a weak defined symbol is linked with a normal defined symbol, the normal defined symbol is used with no error.  When a weak undefined symbol is linked and the symbol is not defined, the value of the weak
    symbol becomes zero with no error.  On some systems, uppercase indicates that a default value has been specified.

    "W"
    "w" The symbol is a weak symbol that has not been specifically tagged as a weak object symbol.  When a weak defined symbol is linked with a normal defined symbol, the normal defined symbol is used with no error.  When a weak undefined symbol is linked and the symbol is not defined, the value of the symbol is determined in a system-specific manner without error.  On some systems, uppercase indicates that a default value has been specified.

    "-" The symbol is a stabs symbol in an a.out object file.  In this case, the next values printed are the stabs other field, the stabs desc field, and the stab type.  Stabs symbols are used to hold debugging information.

    "?" The symbol type is unknown, or object file format specific.
    

- ¿Es posible saber la dirección de las variables “i” y “j” con el comando nm? ¿Por qué? ¿En qué zona de memoria están reservadas estas variables? Busca también la dirección asignada a la función “suma”.

    La dirección de la variable j es "0000000000004014". Solo se puede consulatr las direcciones de las variables globales, como es el caso de j. Las locales como i no podemos saber su direccion ya que se encuentran en la pila. Las variables globales estan en "_GLOBAL_OFFSET_TABLE_", es decir, a partir de la dirección "0000000000004000". La dirección de la variable suma es "00000000000011c9".


 - Utiliza el comando gcc para compilar el fichero mem1_previo.c enlazándolo con librerías estáticas. Indica en el fichero “previo.txt” qué comando has utilizado
 
    Para compilar hemos usado el comando "gcc -static -o mem1_previo.x mem1_previo.c"


 - Anota en el fichero previo.txt el tamaño total de la region de heap y datos para los siguientes números de elementos del vector: 10 y 40000. ¿Existe alguna diferencia entre los distintos valores de las ejecuciones de ambos programas?
 
    Sí que hay diferencia. En mem2_previo el heap tiene el mismo tamaño para i = 10 e y = 40000, ya que el vector no depende de la variable.
    En mem2_previo el vector creado depende de la variable y, por tanto, el tamaño será distinto.

mem2_previo (i=10)
00400000-00401000 r--p 00000000 08:07 525898                             /home/marc/SO/S5/sesion5 plantillas/mem2_previo
00401000-00496000 r-xp 00001000 08:07 525898                             /home/marc/SO/S5/sesion5 plantillas/mem2_previo
00496000-004bd000 r--p 00096000 08:07 525898                             /home/marc/SO/S5/sesion5 plantillas/mem2_previo
004be000-004c1000 r--p 000bd000 08:07 525898                             /home/marc/SO/S5/sesion5 plantillas/mem2_previo
004c1000-004c4000 rw-p 000c0000 08:07 525898                             /home/marc/SO/S5/sesion5 plantillas/mem2_previo
004c4000-004ed000 rw-p 00000000 00:00 0 
01fd5000-01ff8000 rw-p 00000000 00:00 0                                  [heap]
Tamaño del heap: 0x0221a000-0x021f7000 = 0x23000

mem2_previo (i=40000)
00400000-00401000 r--p 00000000 08:07 525898                             /home/marc/SO/S5/sesion5 plantillas/mem2_previo
00401000-00496000 r-xp 00001000 08:07 525898                             /home/marc/SO/S5/sesion5 plantillas/mem2_previo
00496000-004bd000 r--p 00096000 08:07 525898                             /home/marc/SO/S5/sesion5 plantillas/mem2_previo
004be000-004c1000 r--p 000bd000 08:07 525898                             /home/marc/SO/S5/sesion5 plantillas/mem2_previo
004c1000-004c4000 rw-p 000c0000 08:07 525898                             /home/marc/SO/S5/sesion5 plantillas/mem2_previo
004c4000-004ed000 rw-p 00000000 00:00 0 
00517000-0053a000 rw-p 00000000 00:00 0                                  [heap]

Tamaño del heap: 0x0221a000-0x021f7000 = 0x23000

mem2_previo_v2 (i=10)
00400000-00401000 r--p 00000000 08:07 527722                             /home/marc/SO/S5/Sessió 5 - Previ/mem2_previo_v2
00401000-00496000 r-xp 00001000 08:07 527722                             /home/marc/SO/S5/Sessió 5 - Previ/mem2_previo_v2
00496000-004bd000 r--p 00096000 08:07 527722                             /home/marc/SO/S5/Sessió 5 - Previ/mem2_previo_v2
004be000-004c1000 r--p 000bd000 08:07 527722                             /home/marc/SO/S5/Sessió 5 - Previ/mem2_previo_v2
004c1000-004c4000 rw-p 000c0000 08:07 527722                             /home/marc/SO/S5/Sessió 5 - Previ/mem2_previo_v2
004c4000-004c5000 rw-p 00000000 00:00 0 
00f6a000-00f8e000 rw-p 00000000 00:00 0                                  [heap]

Tamaño del heap: 0x00710000-0x006ec000 = 0x24000

mem2_previo_v2 (i=40000)
00400000-00401000 r--p 00000000 08:07 527722                             /home/marc/SO/S5/Sessió 5 - Previ/mem2_previo_v2
00401000-00496000 r-xp 00001000 08:07 527722                             /home/marc/SO/S5/Sessió 5 - Previ/mem2_previo_v2
00496000-004bd000 r--p 00096000 08:07 527722                             /home/marc/SO/S5/Sessió 5 - Previ/mem2_previo_v2
004be000-004c1000 r--p 000bd000 08:07 527722                             /home/marc/SO/S5/Sessió 5 - Previ/mem2_previo_v2
004c1000-004c4000 rw-p 000c0000 08:07 527722                             /home/marc/SO/S5/Sessió 5 - Previ/mem2_previo_v2
004c4000-004c5000 rw-p 00000000 00:00 0 
0141e000-01469000 rw-p 00000000 00:00 0                                  [heap]

Tamaño del heap: 0x00fee000-0x00fc1000 = 0x4B000


Sí que hay diferencia. En mem2_previo el heap tiene el mismo tamaño para i = 10 y i = 10000 ya que el tamaño del vector no depende de la variable.
En mem2_previo el vector creado depende de la variable y, por lo tanto, el tamaño será distinto.
