OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-01-15T21:14:02.737868+01:00' ],		#prior : OmReference [ 'Pharo.dcxa5pogulml2cq02xk54iofc', '58' ],		#self : OmReference [ '1' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'ProtoObject',				#traitCompositionSource : '{}',				#definitionSource : 'ProtoObject subclass: #Object\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'DependentsFields\'\r\tpoolDictionaries: \'\'\r\tcategory: \'Kernel-Objects\''			},			#name : #Object,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Object class\r\tinstanceVariableNames: \'\''				},				#name : #'Object class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Object,					#isMetaSide : false				},				#parent : @7,				#content : 'Object is the root class for almost all of the other classes in the class hierarchy. The exceptions are ProtoObject (the superclass of Object) and its subclasses.\r\rClass Object provides default behavior common to all normal objects, such as access, copying, comparison, error handling, message sending, and reflection. Also utility messages that all objects should respond to are defined here.\r\rObject has no instance variables, nor should any be added. This is due to several classes of objects that inherit from Object that have special implementations (SmallInteger and UndefinedObject for example) or the VM knows about and depends on the structure and layout of certain standard classes.\r\rClass Variables:\r\tDependentsFields\t\tan IdentityDictionary\r\t\tProvides a virtual \'dependents\' field so that any object may have one\r\t\tor more dependent views, synchronized by the changed:/update: protocol.\r\t\tNote that class Model has a real slot for its dependents, and overrides\r\t\tthe associated protocol with more efficient implementations.\r\rBecause Object is the root of the inheritance tree, methods are often defined in Object to give all objects special behaviors needed by certain subsystems or applications, or to respond to certain general test messages such as isMorph.\r\r\r\r\r\rMiscellanous Discussions.\r\rAbout at: index accepting float and not only integers\r \rThis behavior is also free in the sense that the failure code is only invoked when the\rprimitive fails and so adds nothing to the cost of successful accesses,\rwhich are the high dynamic frequency operation.  It will also show up under\rprofiling if one is concerned about efficiency, and so isn\'t a hidden cost.\r\rIt is also in keeping with Smalltalk\'s mixed mode/arbitrary precision\rimplicit coercion number system that one *can* use fractions or floats as\rindices.  Stripping out coercions like this will make the system more brittle.  So \rplease do *not* remove this "hack".  I think it\'s a feature and a useful  one.\r\rCan you give me an example that demonstrates the usefulness of this\rfeature?\r\r| a r |\ra := Array new: 10 withAll: 0.\rr := Random new.\r100 timesRepeat: [| v | v := r next * 10 + 1. a at: v put: (a at: v) + 1].\ra\r\ri.e. I didn\'t have to provide an explicit rounding step.  That\'s useful.  But in general anywhere \rwhere an index is derived by some calculation not having to provide the rounding step could be \ruseful/helpful/more concise.  e.g. (n roundTo: 0.1) * 10 vs ((n roundTo: 0.1) * 10) asInteger.\r\rSome thought went into the original choice.  It is not a hack but there by intent.  The integers are \rsimply a subset of the reals and forcing the programmer to use them is favouring the machine \rabove the programmer.\r\rBut I think you should justify getting rid of it rather than my having to justify keeping it.  Getting \rrid of it risks breaking code.  If it is there but does not harm then why get rid of it?\r\rbest Eliot Miranda \r\r',				#stamp : '<historical>'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Object,						#isMetaSide : false					},					#name : #DependentsFields,					#parent : @7				}			],			#category : #Kernel-Objects,			#package : #Kernel,			#sharedPools : OrderedCollection [ ]		},		#protocol : #customPrueba	}}OmEntry {	#tags : {		#author : 'marc',		#time : DateAndTime [ '2024-01-15T21:17:55.5755+01:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Object class',				#isMetaSide : true			},			#name : #'find:',			#protocol : #'as yet unclassified',			#sourceCode : 'find: aString\r    | matchingSelectors |\r    matchingSelectors := OrderedCollection new.\r\r    self methodDictionary do: [:selector :method |\r        (method getSourceCode includesSubstring: aString)\r            ifTrue: [matchingSelectors add: selector].\r    ].\r\r    ^ matchingSelectors',			#stamp : 'marc 1/15/2024 21:17',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'marc',		#time : DateAndTime [ '2024-01-15T21:21:42.76314+01:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Object class',				#isMetaSide : true			},			#name : #'find:',			#protocol : #'as yet unclassified',			#sourceCode : 'find: aString\r    | matchingSelectors |\r    matchingSelectors := OrderedCollection new.\r\r    self methodDictionary do: [:selector :method |\r        (method getSourceCode includesSubstring: aString)\r            ifTrue: [matchingSelectors add: selector].\r    ].\r\r    ^ matchingSelectors',			#stamp : 'marc 1/15/2024 21:17',			#package : #Kernel		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Object class',				#isMetaSide : true			},			#name : #'find:',			#protocol : #'as yet unclassified',			#sourceCode : 'find: aString\r    | matchingSelectors |\r    matchingSelectors := OrderedCollection new.\r\r    self methodDictionary do: [:selector :method |\r        | methodSource |\r        methodSource := (Decompiler new decompile: method) sourceText.\r        (methodSource includesSubstring: aString)\r            ifTrue: [matchingSelectors add: selector].\r    ].\r\r    ^ matchingSelectors\r',			#stamp : 'marc 1/15/2024 21:21',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'marc',		#time : DateAndTime [ '2024-01-15T21:21:42.930278+01:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Object class',				#isMetaSide : true			},			#name : #'find:',			#protocol : #'as yet unclassified',			#sourceCode : 'find: aString\r    | matchingSelectors |\r    matchingSelectors := OrderedCollection new.\r\r    self methodDictionary do: [:selector :method |\r        | methodSource |\r        methodSource := (Decompiler new decompile: method) sourceText.\r        (methodSource includesSubstring: aString)\r            ifTrue: [matchingSelectors add: selector].\r    ].\r\r    ^ matchingSelectors\r',			#stamp : 'marc 1/15/2024 21:21',			#package : #Kernel		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Object class',				#isMetaSide : true			},			#name : #'find:',			#protocol : #'typing/selecting keys',			#sourceCode : 'find: aString\r    | matchingSelectors |\r    matchingSelectors := OrderedCollection new.\r\r    self methodDictionary do: [:selector :method |\r        | methodSource |\r        methodSource := (Decompiler new decompile: method) sourceText.\r        (methodSource includesSubstring: aString)\r            ifTrue: [matchingSelectors add: selector].\r    ].\r\r    ^ matchingSelectors\r',			#stamp : 'marc 1/15/2024 21:21',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'marc',		#time : DateAndTime [ '2024-01-15T21:23:28.250944+01:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Object class',				#isMetaSide : true			},			#name : #'find:',			#protocol : #'typing/selecting keys',			#sourceCode : 'find: aString\r    | matchingSelectors |\r    matchingSelectors := OrderedCollection new.\r\r    self methodDictionary do: [:selector :method |\r        | methodSource |\r        methodSource := (Decompiler new decompile: method) sourceText.\r        (methodSource includesSubstring: aString)\r            ifTrue: [matchingSelectors add: selector].\r    ].\r\r    ^ matchingSelectors\r',			#stamp : 'marc 1/15/2024 21:21',			#package : #Kernel		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Object class',				#isMetaSide : true			},			#name : #'find:',			#protocol : #'typing/selecting keys',			#sourceCode : 'find: aString\r    | matchingSelectors |\r    matchingSelectors := OrderedCollection new.\r\r    self methodDictionary do: [:selector :method |\r        | methodSource |\r        methodSource := (Decompiler new decompile: (self >> selector)) sourceText.\r        (methodSource includesSubstring: aString)\r            ifTrue: [matchingSelectors add: selector].\r    ].\r\r    ^ matchingSelectors.\r\r',			#stamp : 'marc 1/15/2024 21:23',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'marc',		#time : DateAndTime [ '2024-01-15T21:24:37.483078+01:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Object class',				#isMetaSide : true			},			#name : #'find:',			#protocol : #'typing/selecting keys',			#sourceCode : 'find: aString\r    | matchingSelectors |\r    matchingSelectors := OrderedCollection new.\r\r    self methodDictionary do: [:selector :method |\r        | methodSource |\r        methodSource := (Decompiler new decompile: (self >> selector)) sourceText.\r        (methodSource includesSubstring: aString)\r            ifTrue: [matchingSelectors add: selector].\r    ].\r\r    ^ matchingSelectors.\r\r',			#stamp : 'marc 1/15/2024 21:23',			#package : #Kernel		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Object class',				#isMetaSide : true			},			#name : #'find:',			#protocol : #'typing/selecting keys',			#sourceCode : 'find: aString\r    | matchingSelectors |\r    matchingSelectors := OrderedCollection new.\r\r    self methodDictionary do: [:selector :method |\r        (method getSourceCode includesSubstring: aString)\r            ifTrue: [matchingSelectors add: selector].\r    ].\r\r    ^ matchingSelectors.\r',			#stamp : 'marc 1/15/2024 21:24',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'marc',		#time : DateAndTime [ '2024-01-15T21:28:32.620438+01:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Object class',				#isMetaSide : true			},			#name : #'find:',			#protocol : #'typing/selecting keys',			#sourceCode : 'find: aString\r    | matchingSelectors |\r    matchingSelectors := OrderedCollection new.\r\r    self methodDictionary do: [:selector :method |\r        (method getSourceCode includesSubstring: aString)\r            ifTrue: [matchingSelectors add: selector].\r    ].\r\r    ^ matchingSelectors.\r',			#stamp : 'marc 1/15/2024 21:24',			#package : #Kernel		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Object class',				#isMetaSide : true			},			#name : #'find:',			#protocol : #'typing/selecting keys',			#sourceCode : 'find: aString\r    | matchingSelectors |\r    matchingSelectors := OrderedCollection new.\r\r    self methodDictionary do: [:selector :method |\r        | methodSource |\r        methodSource := (Decompiler new decompile: (self >> selector)) sourceText.\r        (methodSource includesSubstring: aString)\r            ifTrue: [matchingSelectors add: selector].\r    ].\r\r    ^ matchingSelectors',			#stamp : 'marc 1/15/2024 21:28',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'marc',		#time : DateAndTime [ '2024-01-15T21:34:14.484079+01:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Object class',				#isMetaSide : true			},			#name : #'find:',			#protocol : #'typing/selecting keys',			#sourceCode : 'find: aString\r    | matchingSelectors |\r    matchingSelectors := OrderedCollection new.\r\r    self methodDictionary do: [:selector :method |\r        | methodSource |\r        methodSource := (Decompiler new decompile: (self >> selector)) sourceText.\r        (methodSource includesSubstring: aString)\r            ifTrue: [matchingSelectors add: selector].\r    ].\r\r    ^ matchingSelectors',			#stamp : 'marc 1/15/2024 21:28',			#package : #Kernel		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Object class',				#isMetaSide : true			},			#name : #'find:',			#protocol : #'typing/selecting keys',			#sourceCode : 'find: aString\r    | matchingSelectors |\r    matchingSelectors := OrderedCollection new.\r\r    self methodDictionary do: [:selector :method |\r        (method sourceCode includesSubstring: aString)\r            ifTrue: [matchingSelectors add: selector].\r    ].\r\r    ^matchingSelectors\r',			#stamp : 'marc 1/15/2024 21:34',			#package : #Kernel		}	}}OmEntry {	#tags : {		#author : 'marc',		#time : DateAndTime [ '2024-01-15T22:25:36.027154+01:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpCategoryAddition {		#classCategoryName : #Exercicis,		#affectedPackageName : #Exercicis	}}OmEntry {	#tags : {		#author : 'marc',		#time : DateAndTime [ '2024-01-15T22:25:36.057525+01:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #ArbreBinariCerca\r\tinstanceVariableNames: \'arrel\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'Exercicis\''			},			#name : #ArbreBinariCerca,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ArbreBinariCerca,						#isMetaSide : false					},					#name : #arrel,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ArbreBinariCerca class\r\tinstanceVariableNames: \'\''				},				#name : #'ArbreBinariCerca class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ArbreBinariCerca,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #Exercicis,			#package : #Exercicis,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'marc',		#time : DateAndTime [ '2024-01-15T22:29:17.072781+01:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ArbreBinariCerca,				#isMetaSide : false			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize\r    super initialize.\r    arrel := nil',			#stamp : 'marc 1/15/2024 22:29',			#package : #Exercicis		}	}}OmEntry {	#tags : {		#author : 'marc',		#time : DateAndTime [ '2024-01-15T22:30:38.343149+01:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ArbreBinariCerca,				#isMetaSide : false			},			#name : #buida,			#protocol : #'as yet unclassified',			#sourceCode : 'buida\r    ^arrel isNil',			#stamp : 'marc 1/15/2024 22:30',			#package : #Exercicis		}	}}OmEntry {	#tags : {		#author : 'marc',		#time : DateAndTime [ '2024-01-16T00:56:13.279953+01:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMonticelloVersionsLoad {		#versionNames : OrderedCollection [			'Coroutines-CAP2016-17-jjddpp.8'		]	}}OmEntry {	#tags : {		#author : 'marc',		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ],		#time : DateAndTime [ '2024-01-16T00:56:26.922758+01:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Continuation class',				#isMetaSide : true			},			#name : #'callcc:',			#protocol : #'*Coroutines-CAP2016-17',			#sourceCode : 'callcc: aBlock\r\t^ self currentDo: aBlock',			#stamp : 'jjddpp 10/23/2014 17:11',			#package : #Reflection-Complete		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Continuation class',				#isMetaSide : true			},			#name : #'callcc:',			#protocol : #'*Coroutines-CAP2016-17',			#sourceCode : 'callcc: aBlock\r\t^ self currentDo: aBlock ',			#stamp : 'jjddpp 11/10/2016 10:37',			#package : #Reflection-Complete		}	}}OmEntry {	#tags : {		#author : 'marc',		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ],		#time : DateAndTime [ '2024-01-16T00:56:26.969206+01:00' ],		#trigger : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Continuation class',				#isMetaSide : true			},			#name : #'callcc:',			#protocol : #'*Reflection-Complete',			#sourceCode : 'callcc: aBlock\r\t^ self currentDo: aBlock ',			#stamp : 'jjddpp 11/10/2016 10:37',			#package : #Coroutines-CAP2016-17		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Continuation class',				#isMetaSide : true			},			#name : #'callcc:',			#protocol : #'*Coroutines-CAP2016-17',			#sourceCode : 'callcc: aBlock\r\t^ self currentDo: aBlock ',			#stamp : 'jjddpp 11/10/2016 10:37',			#package : #Coroutines-CAP2016-17		}	}}